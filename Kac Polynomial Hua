# Import necessary libraries
from sage.all import *
import itertools

#################################################################################
R.<q> = QQ[]
K = R.fraction_field()

#################################################################################

class QuiverRepresentation:
    """
    A class to represent a quiver with vertices, edges, and a dimension vector.
    
    Attributes:
    vertices : list
        A list of vertices (Q_0) in the quiver.
    edges : list of tuples
        A list of directed edges (Q_1) represented as tuples (start_vertex, end_vertex).
    dimension_vector : list
        A list representing the dimension vector (alpha) corresponding to each vertex.
    """

    def __init__(self, vertices, edges, dimension_vector):
        """
        Initializes the quiver representation with vertices, edges, and dimension vector.
        
        Parameters:
        vertices : list
            The set of vertices (Q_0).
        edges : list of tuples
            The set of directed edges (Q_1).
        dimension_vector : list
            The dimension vector (alpha) for the vertices.
        """
        self.vertices = vertices  # Q_0: Set of vertices
        self.edges = edges  # Q_1: Set of edges (tuples of vertices)
        self.dimension_vector = dimension_vector  # alpha: Dimension vector
        
        variable_names = [f'x{i+1}' for i in range(len(dimension_vector))]
        T = PolynomialRing(K, len(dimension_vector), variable_names)
        self.variables = T.gens()
        
        self.partitions = []

        for i in range(len(dimension_vector)):
            self.partitions.append([])
            for j in range(dimension_vector[i] + 1):
                self.partitions[i] = self.partitions[i] + Partitions(j).list()

    def display(self):
        """
        Prints the vertices, edges, and dimension vector of the quiver.
        """
        print("Vertices (Q_0):", self.vertices)
        print("Edges (Q_1):", self.edges)
        print("Dimension vector (alpha):", self.dimension_vector)
        
    def count_edges_between(self, vertex1, vertex2):
        """
        Counts the number of edges between two vertices.
        
        Parameters:
        vertex1 : any
            First vertex
        vertex2 : any
            Second vertex
        
        Returns:
        int
            The number of edges between vertex1 and vertex2.
        """
        if vertex1 == vertex2:
            return self.edges.count((vertex1, vertex2))
        else:
            return self.edges.count((vertex1, vertex2)) + self.edges.count((vertex2, vertex1))

    def P_numerator(self, Part):
        """
        input: n partitions as an array Part

        Output: Monomial in q
        """
        power = 0
        l = len(self.dimension_vector)

        for i in range(l):
            for j in range(i, l):
                vertex1 = self.vertices[i]
                vertex2 = self.vertices[j]
                ip = inner_product_partitions(Part[i], Part[j])
                
                aij = self.count_edges_between(vertex1, vertex2)                               
                power = power + aij * ip

        numerator = q^power

        return numerator

    def P_denominator(self, Part):
        """
        input: n partitions as an array

        Output: Polynomial in q
        """

        l = len(self.dimension_vector)

        denominator = 1
        for i in range(l):
            ip = inner_product_partitions(Part[i], Part[i])
            b = b_pi(Part[i])
            denominator = denominator * q^ip * b
            

        return denominator

    def P_Gamma(self):
        """
        To compute the polynomial P_{Gamma}(X_1,X_2,...,X_n,q)
        
        Input: 
        
        Output:

        """
        
        P_gamma = 0
        
        # Generate the Cartesian product of the lists
        cartesian_product = itertools.product(*self.partitions)

        # Iterate over each combination in the Cartesian product
        for combination in cartesian_product:
            V = 1
            for i in range(len(combination)):
                V = V * self.variables[i]^sum(combination[i])
            P_gamma = P_gamma + (self.P_numerator(combination) / self.P_denominator(combination)) * V
            
        return P_gamma

####################################################################################

def inner_product_partitions(partition1, partition2):
    # Convert the partitions to Conjugates
    partition1c = Partition(partition1).conjugate()
    partition2c = Partition(partition2).conjugate()
    
    # Compute the inner product as the dot product
    inner_product = 0
    m = min(len(partition1c), len(partition2c))
    for i in range(m):
        inner_product = inner_product + partition1c[i] * partition2c[i]
        
    return inner_product

def b_pi(partition):
    product = 1
    exp = Partition(partition).to_exp()
    for i in exp:
        product = product * Phi(i)
        
    return product


    
def Phi(n):
    product = 1
    if n == 0:
        return 1
    else:
        for i in range(1, n+1):
            product = product * (1 - q^(-i))
        return product

