# Import necessary libraries
from sage.all import *
import itertools

#################################################################################
R.<q> = QQ[]
K = R.fraction_field()

#################################################################################

class QuiverRepresentation:
    """
    A class to represent a quiver with vertices, edges, and a dimension vector.
    
    Attributes:
    vertices : list
        A list of vertices (Q_0) in the quiver.
    edges : list of tuples
        A list of directed edges (Q_1) represented as tuples (start_vertex, end_vertex).
    dimension_vector : list
        A list representing the dimension vector (alpha) corresponding to each vertex.
    """

    def __init__(self, vertices, edges, dimension_vector):
        """
        Initializes the quiver representation with vertices, edges, and dimension vector.
        
        Parameters:
        vertices : list
            The set of vertices (Q_0).
        edges : list of tuples
            The set of directed edges (Q_1).
        dimension_vector : list
            The dimension vector (alpha) for the vertices.
        """
        self.vertices = vertices  # Q_0: Set of vertices
        self.edges = edges  # Q_1: Set of edges (tuples of vertices)
        self.dimension_vector = dimension_vector  # alpha: Dimension vector
        
        variable_names = [f'x{i+1}' for i in range(len(dimension_vector))]
        T = PolynomialRing(K, len(dimension_vector), variable_names)
        self.variables = T.gens()
        
        

    def display(self):
        """
        Prints the vertices, edges, and dimension vector of the quiver.
        """
        print("Vertices (Q_0):", self.vertices)
        print("Edges (Q_1):", self.edges)
        print("Dimension vector (alpha):", self.dimension_vector)
        
    def count_edges_between(self, vertex1, vertex2):
        """
        Counts the number of edges between two vertices.
        
        Parameters:
        vertex1 : any
            First vertex
        vertex2 : any
            Second vertex
        
        Returns:
        int
            The number of edges between vertex1 and vertex2.
        """
        if vertex1 == vertex2:
            return self.edges.count((vertex1, vertex2))
        else:
            return self.edges.count((vertex1, vertex2)) + self.edges.count((vertex2, vertex1))

    def P_numerator(self, Part, w):
        """
        input: n partitions as an array Part

        Output: Monomial in q
        """
        power = 0
        l = len(self.dimension_vector)

        for i in range(l):
            for j in range(i, l):
                vertex1 = self.vertices[i]
                vertex2 = self.vertices[j]
                ip = inner_product_partitions(Part[i], Part[j])
                
                aij = self.count_edges_between(vertex1, vertex2)                               
                power = power + aij * ip

        numerator = w^power

        return numerator

    def P_denominator(self, Part, w):
        """
        input: n partitions as an array

        Output: Polynomial in q
        """

        l = len(self.dimension_vector)

        denominator = 1
        for i in range(l):
            ip = inner_product_partitions(Part[i], Part[i])
            b = b_pi(Part[i], w)
            denominator = denominator * w^ip * b
            

        return denominator

    def P_Gamma(self, Part, w):
        """
        To compute the polynomial P_{Gamma}(X_1,X_2,...,X_n,q)
        
        Input: 
        
        Output:

        """
        
        P_gamma = 0
        
        # Generate the Cartesian product of the lists
        cartesian_product = itertools.product(*Part)

        # Iterate over each combination in the Cartesian product
        for combination in cartesian_product:
            V = 1
            for i in range(len(combination)):
                V = V * self.variables[i]^sum(combination[i])
            P_gamma = P_gamma + (self.P_numerator(combination, w) / self.P_denominator(combination, w)) * V
            
        return P_gamma
    
    def log_P(self, Part, alpha, w):
        """
        Calculates log P series upto the required length
        """
        dim = sum(alpha) + 1
        
        P_gamma_1 = self.P_Gamma(Part, w)-1
        
        log = 0
        
        for i in range(1, dim):
            log = log + ((-1)^(i-1) * P_gamma_1^(i))/i
            
        return log
    
    
    def H_Gamma(self, alpha, w):
        
        """
        Computes H_Gamma by matcing coefficients with log_P
        
        """
            
        a = gcd(alpha)
        
        partitions = []

        for i in range(len(alpha)):
            partitions.append([])
            for j in range(alpha[i] + 1):
                partitions[i] = partitions[i] + Partitions(j).list()
        
        
        V = 1
        
        log_P = self.log_P(partitions, alpha, w)
        
        for i in range(len(alpha)):
                V = V * self.variables[i]^sum(alpha[i])
                
        H_gamma = log_P.monomial_coefficient(V) * a
        
        return H_gamma
    
    
    def A_Gamma(self):
        """
        
        """
        
        a = gcd(self.dimension_vector)
        
        b = (q-1)/a
        
        Div = divisors(a)
        
        A_gamma = 0
        aplha = self.dimension_vector
        for i in Div:
            for j in range(len(alpha)):
                alpha[j] = alpha[j]/i 
            w = q^i
            if moebius(i) == 0:
                A_gamma = A_gamma
            else:
                A_gamma = A_gamma + moebius(i) * self.H_Gamma(alpha, w)
            
            
        A_gamma = b * A_gamma
        
        return A_gamma
        
        
        

####################################################################################

def inner_product_partitions(partition1, partition2):
    # Convert the partitions to Conjugates
    partition1c = Partition(partition1).conjugate()
    partition2c = Partition(partition2).conjugate()
    
    # Compute the inner product as the dot product
    inner_product = 0
    m = min(len(partition1c), len(partition2c))
    for i in range(m):
        inner_product = inner_product + partition1c[i] * partition2c[i]
        
    return inner_product

def b_pi(partition, w):
    product = 1
    exp = Partition(partition).to_exp()
    for i in exp:
        product = product * Phi(i, w)
        
    return product


    
def Phi(n, w):
    product = 1
    if n == 0:
        return 1
    else:
        for i in range(1, n+1):
            product = product * (1 - w^(-i))
        return product

####################################################################################
