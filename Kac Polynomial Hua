# Import necessary libraries
from sage.all import *

#################################################################################
R.<q> = QQ[]

K = R.fraction_field

#################################################################################

class QuiverRepresentation:
    """
    A class to represent a quiver with vertices, edges, and a dimension vector.
    
    Attributes:
    vertices : list
        A list of vertices (Q_0) in the quiver.
    edges : list of tuples
        A list of directed edges (Q_1) represented as tuples (start_vertex, end_vertex).
    dimension_vector : list
        A list representing the dimension vector (alpha) corresponding to each vertex.
    """

    def __init__(self, vertices, edges, dimension_vector):
        """
        Initializes the quiver representation with vertices, edges, and dimension vector.
        
        Parameters:
        vertices : list
            The set of vertices (Q_0).
        edges : list of tuples
            The set of directed edges (Q_1).
        dimension_vector : list
            The dimension vector (alpha) for the vertices.
        """
        self.vertices = vertices  # Q_0: Set of vertices
        self.edges = edges  # Q_1: Set of edges (tuples of vertices)
        self.dimension_vector = dimension_vector  # alpha: Dimension vector
        self.partitions = []
        
        for i in range(len(dimension_vector)):
            self.partitions.append([])
            for j in range(dimension_vector[i]+1):
                self.partitions[i] = self.partitions[i] + Partitions(j).list()

    def display(self):
        """
        Prints the vertices, edges, and dimension vector of the quiver.
        """
        print("Vertices (Q_0):", self.vertices)
        print("Edges (Q_1):", self.edges)
        print("Dimension vector (alpha):", self.dimension_vector)
        
    def count_edges_between(self, vertex1, vertex2):
        """
        Counts the number of edges between two vertices.
        
        Parameters:
        vertex1 : any
            
        vertex2 : any
        
        Returns:
        int
            The number of edges between vertex1 and vertex2.
        """
        if vertex1 == vertex2:
            return self.edges.count((vertex1, vertex2))
        else:
            return self.edges.count((vertex1, vertex2)) + self.edges.count((vertex2, vertex1))

    def P_numerator(self):
        """
        Make sure to double check indices,
        
        input: n partitions as an array Part
        
        Output: Monomial in q 
        """
        power = 0
        l = len(self.dimension_vector)
        
            
        for i in range(1,l):
            for j in range(i,l):
                vertex1 = self.vertices(i)
                vertex2 = self.vertices(j)
                aij = self.count_edges_between(vertex1,vertex2)
                ip = inner_product_partitions(Part[i], Part[j])
                
                power = power + aij * ip
                
        
        
        # Create the polynomial 
        numerator = q^power
        
        return numerator
    
    def P_donominator(self):
        """
        Make sure to double check indices,
        
        input: n partitions as an array 
        
        Output: Polynomial in q 
        """
        
        l = len(self.dimension_vector)
        
        denominator = 1   
        for i in range(1,l):
            ip = inner_product_partitions(Part[i], Part[i])
            b = b_pi(Part[i])
            denominator = denominator * q^ip * b
            
            
                
        
        
        # Create the polynomial 
        
        
        return denominator
                



####################################################################################


def inner_product_partitions(partition1, partition2):

    # Convert the partitions to Conjugates
    partition1c = Partition(partition1).conjugate()
    partition2c = Partition(partition2).conjugate()
    print(partition1c)
    print(partition2c)
    # Compute the inner product as the dot product
    inner_product = 0
    m = min(len(partition1c), len(partition2c))
    for i in range(m):
        inner_product = inner_product + partition1c[i] * partition2c[i]
        
    
    return inner_product

def b_pi(partition):
    
    product = 1
    exp = Partition(partition).to_exp()
    for i in exp:
        product = product * Phi(i)
        
    return product
        

def Phi(int):
    product = 1
    if int == 0:
        return 1
    else:
        for i in range(1,int+1):
            product = product*(1-q^(-i))
        
        return product




####################################################################################

